{
  "id": "930582",
  "title": "장문후기) 왜 GPT 5.2 Pro는 좋은가?",
  "category": "",
  "author": "앵글링스키밍",
  "date": "2026.01.11 00:47:48",
  "views": 0,
  "likes": 0,
  "comments": 0,
  "content": "\n\t\t\t\t\t\t\t<p>본 글은 <b>왜 GPT 5.2pro가 좋았는지 프롬프트 엔지니어링 관점에서 길게 설명하는 후기</b>인데</p><p><font color=\"#ff0000\">핵심은 4 문단부터니 귀찮은 사람은 4문단부터 읽으셈.</font></p><p><br></p><p><br></p><p><span style=\"font-size:30px;\"><b>1. 프롬프트 무작정 길다고 좋은거 아니다.</b></span></p><p><br></p><p>1)&nbsp; LLM은 좋은 프롬프트와 좋은 입력값이 들어갈 때 좋은 답변이 나온다</p><p><br></p><p>2)&nbsp; 좋은 프롬프트를 만드는것부터 일단 어렵다.</p><p><br></p><p>3)&nbsp; 길고 자세한 프롬프트는 많은것들을 할 수 있지만 단점도 많다.</p><p>&nbsp; 컨텍스트 윈도우와 토큰은 유한하기 때문에, 다 때려박는다고 다 해주진 못한다.</p><p><br></p><p>4)&nbsp; 모델이 븅신일수록 허용하고 금지할게 많아진다. -&gt; 프롬프트가 쓸데없이 길어진다</p><p>&nbsp; +모델 입장에서 판단이 어려워지고, 유저 입장에서도 충돌 관리할게 많아진다.</p><p><br></p><p><b><font color=\"#ff0000\">5)&nbsp; ((((중요)))) 너무 길면 걍 안지키고 ai 좆대로 한다.</font></b></p><p><br></p><p><br></p><p><span style=\"font-size:30px;\"><b>2. 하나로 모든 작업을 커버하는 만능 프롬프트는 없다.</b></span></p><p>LLM에게 좋은 답변을 얻기 위해서는 <b>프롬프트 엔지니어링에서 어떤 것이 중요한지(우선순위)</b> + <b>나의 목표와 어떻게 상호작용하는지</b> 스스로 깨달아야함.</p><p><br></p><p><b>전자</b>는 이미 똑똑한 형님들이 먼저 다 겪어보시고 내놓은 원칙들이 많고</p><p><b>후자</b>는 직접 경험해보는수밖에 없음. 논리적으로 이론적으로 다 맞아도 실제 모델에 넣어서 돌려보기 전까진 모름ㅋㅋ</p><p><br></p><p>그래서<font color=\"#0000ff\"> <b>해결 방안</b></font>은<b> 3종류</b>가 있음.</p><p><br></p><p>1) (아래 4문단에서 설명할거지만)</p><p>GPT 5.2 Pro같은 걍 존나 좋은모델을 쓴다</p><p><br></p><p>2) 념글 gems 올려주는 유저처럼 남이 잘 만들어놓은걸 용도별로 싹 갖다쓴다</p><p><br></p><p>3)&nbsp; 스스로 프롬프트를 짜서 쓰고 유지보수한다 (글쓴이가 삽질중인 단계)</p><p><br></p><p><br></p><p><b><span style=\"font-size:30px;\">3. ‘2-pass 구조’ (글쓴이가 썼던 만능 프롬프트)</span></b></p><p><br></p><div><br></div><p style=\"height:1px\">&nbsp;</p><div class=\"og-div\" style=\"margin-top:5px\"><a href=\"https://drive.google.com/file/d/1TDWSGxJGt_kQV_5x9fXOlHQrsUCx6dfi/view?usp=sharing\" target=\"_blank\" class=\"og-wrap\" style=\"display:inline-block;width:70%;height:105px;background:#fff;border:1px solid #dfe1ee;box-sizing:border-box;letter-spacing:-1px;overflow:hidden;line-height:1.5\"><div class=\"og-img\" style=\"float:left;width:104px;height:100%;box-sizing: border-box;border-right: 1px solid #dfe1ee;\" data-img=\"https://nstatic.dcinside.com/dc/w/images/minorbg.png\"><img class=\"og-img\" referrerpolicy=\"no-referrer\" src=\"https://nstatic.dcinside.com/dc/w/images/minorbg.png\" alt=\"\" style=\"width:100%!important;height:100%!important;object-fit: cover;object-position: center center\"></div><div class=\"og-info\" style=\"float:right;width:calc(100% - 104px);height:100%;box-sizing:border-box;padding:12px\"><div class=\"og-inr\" style=\"display: inline-block;max-width: 100%;text-overflow: ellipsis;white-space: nowrap;overflow: hidden;font-size: 14px;font-weight:bold\"><strong class=\"og-tit\" style=\"display: inline-block;max-width: 100%;font-size: 14px;vertical-align: top;padding-right: 1px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis\">공유용 2pass구조 프롬프트.txt </strong></div><p class=\"og-txt\" style=\"width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#000;margin:2px 0 11px\">공유용 2pass구조 프롬프트.txt</p><p class=\"og-lnk\" style=\"width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#3b4890\">drive.google.com</p></div></a></div><p>간단하게 뭔지 설명하자면,&nbsp;</p><p><b><font color=\"#0000ff\">생각하는 시간(Pass 1)과 말하는 시간(Pass 2)을 강제로 분리하는 것</font></b>임</p><p><br></p><p>즉,</p><p><font color=\"#ff0000\">1)&nbsp; 먼저 생각하고(Pass 1),</font></p><p><font color=\"#ff0000\">2)&nbsp; 검증된 것만 말한다(Pass 2).</font></p><p><font color=\"#ff0000\">3)&nbsp; 아니면 쿨하게 모른다고 한다(Fail-soft).</font></p><p><br></p><p>이 워크플로우를 LLM에게 강제하는것임.</p><p><br></p><p>난 몰랐는데, CoT는 만능이 아니고 내부 사고 과정을 다 보여주는것도 아님. (즉 씹구라임.)</p><p>그래서 모델이 먼저 논리 구조를 확인하고, 그걸 답변의 맨 처음에 무조건 출력하도록 하는것임.</p><p><br></p><p>이게 <b><font color=\"#ff0000\">환각 방지에 아주 큰 도움이 됨.</font></b></p><p><br></p><p><img src=\"https://dcimg8.dcinside.co.kr/viewimage.php?id=39b5d535ecdc3fb362bec4bc02c8&amp;no=24b0d769e1d32ca73de88ffa1bd62531b4a124fe2dbe54c3cab70d3d8ef91a375999724f327e9b7351f43cb567d0a75c58587235f38d180493de8bd214fcafa82625ffdedcec41\" onerror=\"reload_img(this)\" loading=\"lazy\" data-fileno=\"419621\" alt=\"a66e30ab1c2ab356a6805a5fd25cc5f16177e5b2d598c1e6cd88610a310cbb41f86264ff3ace766aa959230dc544b36ecb2013e0ceaf0d326f8b61b6\"></p><p><br></p><p><br></p><p>그리고 더 중요한건, <font color=\"#ff0000\">환각이어도 유저가 <b>디버깅(이새끼 병신짓했나 안했나 검사)</b>하기가 매우 쉽고 편해짐.</font></p><p><br></p><p><br></p><p><span style=\"font-size:30px;\"><b>4. 왜 GPT 5.2 Pro는 좋은가?</b></span></p><p><br></p><p><b>Gemini 3 Pro</b> 쓰다가 한방에 <b>GPT 5.2 Pro extended</b>로 왔는데,&nbsp;</p><p>얘는 너무 똑똑해서 위의 2-pass구조를 굳이 지시사항에 넣을 필요가 없을 것 같음</p><p><br></p><p><img src=\"https://nstatic.dcinside.com/dc/m/img/gallview_loading_ori.gif\" data-original=\"https://dcimg8.dcinside.co.kr/viewimage.php?id=39b5d535ecdc3fb362bec4bc02c8&amp;no=24b0d769e1d32ca73de88ffa1bd62531b4a124fe2dbe54c3cab70d3d8ef91a375999724f327e9b7351f43cb567d0a75143b54a6c42e98f923e95a74fae7312b60c3cb3d10adea8\" class=\"lazy\" data-fileno=\"419622\" alt=\"a66e30ab1c2ab356a6805a5fd25cc5f16177e5b2d598c1e6cd88610a310cbb41f86264ff3bcd706fa70674469b73886840563a806ae4a766d2\"></p><p><br></p><p>요즘 부쩍 느끼는게, <b>지시사항에 넣을 수 있는 실질적인 글자수나 명령수는 한정되어 있음.</b></p><p>그리고 <b>구린 모델일수록 </b>아주 기본적인 것부터 몇줄씩 써가며 문제를 때려잡느라, 진짜 내가 원하는 세세한 디테일들을 넣을 공간이 없어짐.</p><p><br></p><p>근데 <b>5.2 Pro는 이미 사고 과정에 내가 gemini에 지시사항으로 넣어서 쓰던것들이 이미 탑재되어 있는 느낌</b>임.</p><p>굳이 지시사항에 넣지 않아도 잘 지키고 좋은 답변을 내줌….</p><p><br></p><p>오히려 내가 강제한 논리 구조나 출력 양식을 따라가느라 시간만 더 걸리고 토큰만 더 소모하는 느낌.</p><p><br></p><p>그래서 요즘은 2-pass를 빼고 내가 원하는 마이크로 디테일들을 지시사항에 넣으려고 생각중.</p><p>이게 좋은 모델을 쓰는 장점 아닐까? 개인적으로 매우 만족하고 있음.</p><p><br></p><p><br></p><p><br></p><p><b><span style=\"font-size:30px;\">5. 엔트로픽의 3대 원칙</span></b></p><p><br></p><p>개 삽질하면서 뭐가 우선순위일까 시행착오 겪던 와중에</p><p>최근 엔트로픽이 공개한 논문의 3원칙이 내가 삽질하면서 얻은 내용이랑 비슷해서 가져와봄.</p><p><br></p><p><font color=\"#ff0000\">걍 잘 모르겠고 앞으로 아래 3원칙을 최우선 기준으로 삼는게 좋을 것 같음.</font></p><p><strike>아 혼자 븅신짓하지말고 걍 똑똑한 형님들이 논문 낸거나 읽을걸 ㅅ발 내 시간</strike></p><p><br></p><p><b><font color=\"#0000ff\">1)&nbsp; &nbsp;줄글 대신 XML 태그를 사용하여 데이터의 경계를 명확히 구분해야 모델이 구조적으로 인식한다.&nbsp;</font></b></p><p>Q. 근거 (Evidence): &lt;document&gt; 같은 태그로 정보를 감싸면, 클로드(Claude) 모델은 이를 마치 JSON 파싱하듯 명확한 데이터 구조로 인지하여 성능이 향상된다.&nbsp;</p><p><br></p><p><b><font color=\"#0000ff\">2)&nbsp; AC(Agent Computer Interface) 최적화를 위해, 함수 이름과 설명은 인간이 아닌 AI가 이해하기 쉽게(Verbose) 작성해야 한다.&nbsp;</font></b></p><p><br></p><p>Q. 예시 (Example): 인간용 getData() 대신, Al용으로는 search financial records() 처럼 목적이 드러난 긴 이름을 써야 툴 사용의 정확도가 올라간다.&nbsp;</p><p><br></p><p><b><font color=\"#0000ff\">3)&nbsp; &nbsp;모든 예외를 하드코딩하지 말고, 모델이 상황을 판단할 수 있는 '생각의 프로세스(추론 원칙)'를 심어주어야 한다.&nbsp;</font></b></p><p><br></p><p>Q. 근거 (Evidence): '골디락스 시스템 프롬프트' 원칙에 따라, 100개의 예외 규칙을 나열하는 것보다 물고기 잡는 법(추론 루트)을 가르치는 것이 컨텍스트 길이를 줄이고 유연성을 높인다.</p>\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t",
  "contentText": "본 글은 왜 GPT 5.2pro가 좋았는지 프롬프트 엔지니어링 관점에서 길게 설명하는 후기인데핵심은 4 문단부터니 귀찮은 사람은 4문단부터 읽으셈.1. 프롬프트 무작정 길다고 좋은거 아니다.1)  LLM은 좋은 프롬프트와 좋은 입력값이 들어갈 때 좋은 답변이 나온다2)  좋은 프롬프트를 만드는것부터 일단 어렵다.3)  길고 자세한 프롬프트는 많은것들을 할 수 있지만 단점도 많다.  컨텍스트 윈도우와 토큰은 유한하기 때문에, 다 때려박는다고 다 해주진 못한다.4)  모델이 븅신일수록 허용하고 금지할게 많아진다. -> 프롬프트가 쓸데없이 길어진다  +모델 입장에서 판단이 어려워지고, 유저 입장에서도 충돌 관리할게 많아진다.5)  ((((중요)))) 너무 길면 걍 안지키고 ai 좆대로 한다.2. 하나로 모든 작업을 커버하는 만능 프롬프트는 없다.LLM에게 좋은 답변을 얻기 위해서는 프롬프트 엔지니어링에서 어떤 것이 중요한지(우선순위) + 나의 목표와 어떻게 상호작용하는지 스스로 깨달아야함.전자는 이미 똑똑한 형님들이 먼저 다 겪어보시고 내놓은 원칙들이 많고후자는 직접 경험해보는수밖에 없음. 논리적으로 이론적으로 다 맞아도 실제 모델에 넣어서 돌려보기 전까진 모름ㅋㅋ그래서 해결 방안은 3종류가 있음.1) (아래 4문단에서 설명할거지만)GPT 5.2 Pro같은 걍 존나 좋은모델을 쓴다2) 념글 gems 올려주는 유저처럼 남이 잘 만들어놓은걸 용도별로 싹 갖다쓴다3)  스스로 프롬프트를 짜서 쓰고 유지보수한다 (글쓴이가 삽질중인 단계)3. ‘2-pass 구조’ (글쓴이가 썼던 만능 프롬프트) 공유용 2pass구조 프롬프트.txt 공유용 2pass구조 프롬프트.txtdrive.google.com간단하게 뭔지 설명하자면, 생각하는 시간(Pass 1)과 말하는 시간(Pass 2)을 강제로 분리하는 것임즉,1)  먼저 생각하고(Pass 1),2)  검증된 것만 말한다(Pass 2).3)  아니면 쿨하게 모른다고 한다(Fail-soft).이 워크플로우를 LLM에게 강제하는것임.난 몰랐는데, CoT는 만능이 아니고 내부 사고 과정을 다 보여주는것도 아님. (즉 씹구라임.)그래서 모델이 먼저 논리 구조를 확인하고, 그걸 답변의 맨 처음에 무조건 출력하도록 하는것임.이게 환각 방지에 아주 큰 도움이 됨.그리고 더 중요한건, 환각이어도 유저가 디버깅(이새끼 병신짓했나 안했나 검사)하기가 매우 쉽고 편해짐.4. 왜 GPT 5.2 Pro는 좋은가?Gemini 3 Pro 쓰다가 한방에 GPT 5.2 Pro extended로 왔는데, 얘는 너무 똑똑해서 위의 2-pass구조를 굳이 지시사항에 넣을 필요가 없을 것 같음요즘 부쩍 느끼는게, 지시사항에 넣을 수 있는 실질적인 글자수나 명령수는 한정되어 있음.그리고 구린 모델일수록 아주 기본적인 것부터 몇줄씩 써가며 문제를 때려잡느라, 진짜 내가 원하는 세세한 디테일들을 넣을 공간이 없어짐.근데 5.2 Pro는 이미 사고 과정에 내가 gemini에 지시사항으로 넣어서 쓰던것들이 이미 탑재되어 있는 느낌임.굳이 지시사항에 넣지 않아도 잘 지키고 좋은 답변을 내줌….오히려 내가 강제한 논리 구조나 출력 양식을 따라가느라 시간만 더 걸리고 토큰만 더 소모하는 느낌.그래서 요즘은 2-pass를 빼고 내가 원하는 마이크로 디테일들을 지시사항에 넣으려고 생각중.이게 좋은 모델을 쓰는 장점 아닐까? 개인적으로 매우 만족하고 있음.5. 엔트로픽의 3대 원칙개 삽질하면서 뭐가 우선순위일까 시행착오 겪던 와중에최근 엔트로픽이 공개한 논문의 3원칙이 내가 삽질하면서 얻은 내용이랑 비슷해서 가져와봄.걍 잘 모르겠고 앞으로 아래 3원칙을 최우선 기준으로 삼는게 좋을 것 같음.아 혼자 븅신짓하지말고 걍 똑똑한 형님들이 논문 낸거나 읽을걸 ㅅ발 내 시간1)   줄글 대신 XML 태그를 사용하여 데이터의 경계를 명확히 구분해야 모델이 구조적으로 인식한다. Q. 근거 (Evidence): <document> 같은 태그로 정보를 감싸면, 클로드(Claude) 모델은 이를 마치 JSON 파싱하듯 명확한 데이터 구조로 인지하여 성능이 향상된다. 2)  AC(Agent Computer Interface) 최적화를 위해, 함수 이름과 설명은 인간이 아닌 AI가 이해하기 쉽게(Verbose) 작성해야 한다. Q. 예시 (Example): 인간용 getData() 대신, Al용으로는 search financial records() 처럼 목적이 드러난 긴 이름을 써야 툴 사용의 정확도가 올라간다. 3)   모든 예외를 하드코딩하지 말고, 모델이 상황을 판단할 수 있는 '생각의 프로세스(추론 원칙)'를 심어주어야 한다. Q. 근거 (Evidence): '골디락스 시스템 프롬프트' 원칙에 따라, 100개의 예외 규칙을 나열하는 것보다 물고기 잡는 법(추론 루트)을 가르치는 것이 컨텍스트 길이를 줄이고 유연성을 높인다.",
  "images": [
    {
      "url": "https://nstatic.dcinside.com/dc/w/images/minorbg.png"
    },
    {
      "url": "https://dcimg8.dcinside.co.kr/viewimage.php?id=39b5d535ecdc3fb362bec4bc02c8&no=24b0d769e1d32ca73de88ffa1bd62531b4a124fe2dbe54c3cab70d3d8ef91a375999724f327e9b7351f43cb567d0a75c58587235f38d180493de8bd214fcafa82625ffdedcec41",
      "alt": "a66e30ab1c2ab356a6805a5fd25cc5f16177e5b2d598c1e6cd88610a310cbb41f86264ff3ace766aa959230dc544b36ecb2013e0ceaf0d326f8b61b6"
    },
    {
      "url": "https://nstatic.dcinside.com/dc/m/img/gallview_loading_ori.gif",
      "alt": "a66e30ab1c2ab356a6805a5fd25cc5f16177e5b2d598c1e6cd88610a310cbb41f86264ff3bcd706fa70674469b73886840563a806ae4a766d2"
    }
  ],
  "url": "https://gall.dcinside.com/mgallery/board/view/?id=thesingularity&no=930582",
  "crawledAt": "2026-01-11T00:44:52.190Z",
  "selectedAt": "2026-01-11T00:49:13.303Z",
  "selectedBy": "auto",
  "qualityScore": 30
}