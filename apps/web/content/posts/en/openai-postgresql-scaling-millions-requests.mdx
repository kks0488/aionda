---
title: "Scaling PostgreSQL to Millions of Queries per Second"
slug: "openai-postgresql-scaling-millions-requests"
date: "2026-02-12"
lastReviewedAt: "2026-02-12"
locale: "en"
description: "OpenAI shares scaling PostgreSQL to millions of QPS using replicas, caching, rate limiting, and workload isolation to protect DB paths."
tags: ["hardware", "llm", "robotics", "deep-dive"]
author: "AIÏò®Îã§"
sourceId: "openai-oldwdq"
sourceUrl: "https://openai.com/index/scaling-postgresql"
verificationScore: 0.75
alternateLocale: /ko/posts/openai-postgresql-scaling-millions-requests
coverImage: "/images/posts/openai-postgresql-scaling-millions-requests.png"
---

## TL;DR

- **What changed / what this is:** A PostgreSQL scaling case described **millions of queries per second**, using replicas, caching, rate limiting, and isolation.  
- **Why it matters:** LLM services can bottleneck on DB paths like sessions and billing, not only inference.  
- **What to do next:** Review read/write separation, cache coverage, surge controls, and isolation as a single plan.  

When users see slower responses, engineers often suspect load concentrating on one database.  
Internally, query volume can spike.  
Lock contention can increase.  
Cache misses can rise at the same time.  
A described case scaled PostgreSQL to **millions of queries per second**.  
It highlighted **replicas, caching, rate limiting, workload isolation** as key levers.  

Example: A user opens a chat screen and the list feels slow. The team checks read hotspots and background jobs sharing resources.

## Current state

A disclosed case described scaling PostgreSQL to **millions of queries per second (millions of queries per second)**.  
The described measures were four items.  
They were **replicas, caching, rate limiting, workload isolation**.  
These four items are directly stated in the excerpts used here.  
The only numeric scale claim in these excerpts is **‚Äúmillions of queries per second.‚Äù**  

This text does not specify the detailed architecture.  
It does not identify a cache product.  
It does not indicate whether sharding was used.  
It does not describe a cloud or deployment model.  
Those missing details limit what can be inferred from this write-up alone.  

This text also does not provide other scale metrics.  
It does not mention user counts.  
It does not mention request counts outside the DB query rate.  
For now, the verifiable scale expression remains **‚Äúmillions of queries per second.‚Äù**  

## Analysis

This case suggests the bottleneck in AI services can include the database layer.  
It suggests the bottleneck is not only GPUs.  
Conversational products include non-generation paths.  
They include authentication and sessions.  
They can include message indexing.  
They can include policy or abuse checks.  
They can include billing.  
Some of these paths can involve relational DB transactions.  

When load concentrates on a single DB, query tuning may not be enough.  
Recovery can require structural controls.  
That context makes a bundled approach plausible.  
The bundle is **replication + caching + rate limiting + isolation**.  
Confirming details would require the full original source.  

The trade-offs can be framed explicitly.  

- **Replicas / Caching** can reduce read latency.  
  Replication lag can create consistency risks.  
  Cache invalidation failures can also create consistency risks.  
- **Rate limiting** can reduce spikes and abuse.  
  Coarse settings can block legitimate users.  
  That creates false positives.  
- **Workload isolation** can limit blast radius.  
  Isolation boundaries still need ongoing management.  
  This includes resources, permissions, and procedures.  

The message leans away from ‚Äútune the DB harder.‚Äù  
It leans toward ‚Äúset operating boundaries first.‚Äù  
Those boundaries can reduce collapse risk under surges.  

### Decision Memo: Selection criteria in If/Then form

- **If** the read ratio is high and lookups repeat, **Then** design replica + caching first.  
  - Benefits: reduced DB read load, improved response latency  
  - Costs: replication lag, cache invalidation risks, added operational complexity  

- **If** traffic spikes are frequent or abuse is a concern, **Then** treat rate limiting as a safety guardrail.  
  - Benefits: higher failure threshold, mitigated cost spikes  
  - Costs: false-positive blocking risk, possible increases in failure-rate metrics  

- **If** batch workloads and online requests compete on the same DB, **Then** create boundaries via workload isolation.  
  - Benefits: reduced chance one incident propagates into the other side‚Äôs SLA  
  - Costs: more synchronization work, pipelines, and operating procedures  

## Practical application

A reasonable sequence is stability first, then throughput, then fine tuning.  
Stability can include surge control and isolation.  
Throughput can include replication and caching.  
Then detailed tuning can become easier to validate.  

If you run a PostgreSQL service, start with observability.  
Try to separate likely bottlenecks.  
They can be CPU, IO, locks, or network.  
Then review rate limiting policies.  
Also review structural choices.  
Those include isolation, replication, and caching.  
This approach can reduce trial-and-error cycles.  

**Checklist for Today:**
- Map read and write paths, and note where a replica or cache could serve reads.  
- Review rate limiting rules, and confirm logs can distinguish abuse from false positives.  
- Define workload isolation boundaries, and document which jobs belong to each boundary.  

## FAQ

**Q1. How far can PostgreSQL scale?**  
A. These excerpts mention **millions of queries per second**.  
The configuration and query mix are not specified here.  
So the conditions behind that figure remain unclear.  

**Q2. Which should we do first: replica or caching?**  
A. Caching can help when repeated reads are common.  
It can help when freshness requirements are lower.  
A replica can help when freshness needs are higher.  
It can help when read traffic is structurally large.  
If you use both, treat lag and invalidation as separate incident scenarios.  

**Q3. Is rate limiting performance optimization or a security feature?**  
A. It can function as both.  
It can protect stability by delaying failure under spikes.  
It can also limit cost growth under abuse.  
False-positive blocking remains possible.  
Design thresholds, exceptions, and observability together.  

## Conclusion

The emphasis is a protective posture for the database layer.  
It combines **replicas, caching, rate limiting, workload isolation**.  
The next decision inputs are operational details.  
They include consistency criteria.  
They include isolation boundaries.  
They include observability metrics.  
If more primary material becomes available, those details can be checked.

## Further Reading
- [AI Resource Roundup (24h) - 2026-02-12](/en/posts/ai-resources-roundup-2026-02-12)
- [AI Resource Roundup (6h) - 2026-02-11](/en/posts/ai-resources-roundup-2026-02-11)
- [AI Resource Roundup (24h) - 2026-02-10](/en/posts/ai-resources-roundup-2026-02-10)
- [Enhancing Code Refactoring and Functional Integrity With AI Models](/en/posts/ai-code-refactoring-and-functional-integrity)
- [Balancing Productivity and Security in AI Assisted Software Development](/en/posts/ai-coding-security-for-solo-developers)
---

## References

- üõ°Ô∏è [openai.com](https://openai.com/index/scaling-postgresql)
