---
title: 'clawdbot(moltbot) 사용기: 며칠 써보고 삭제한 이유'
slug: clawdbot-moltbot-usage-review
date: '2026-01-29'
locale: ko
description: >-
  며칠간 실개발에 붙여본 clawdbot(moltbot) 사용기. 모바일 코딩·채팅 UX·워크플로우 관점에서 순정 CLI로 돌아간 이유를
  정리합니다.
tags:
  - llm
  - coding
  - workflow
  - tooling
  - claude-code
  - codex
  - field-notes
  - review
  - explainer
author: AI온다
byline: 'Aionda Team(공동필명) · 편집: AI온다'
sourceId: manual-clawdbot-moltbot-usage-review
alternateLocale: /en/posts/clawdbot-moltbot-usage-review
coverImage: /images/posts/clawdbot-moltbot-usage-review.png
---

## 세 줄 요약
- clawdbot(moltbot)을 며칠 써본 뒤, 내 작업 흐름에서는 “새로운 패러다임”보다 “Claude Code 래퍼”에 가깝다고 느껴 삭제했다.
- 모바일 코딩/메모리/에이전트 자동화의 장점이 내 환경(Tailscale+Termius+tmux)과 겹치거나, 채팅 UX가 통제력을 떨어뜨리는 지점이 컸다.
- 새 도구를 붙이기 전, “내 작업 방식이 바뀌는 순간”을 체크리스트로 정의하고 순정 CLI로도 되는지 먼저 실험해보자.

## 공개
- 이 글은 협찬/광고 없이 작성했습니다.
- 제품 제공/금전적 이해관계가 없습니다. (직접 실사용 기반)

## 환경
- 원격/터미널: Tailscale + Termius + tmux
- 비교 기준: tmux 안에서 순정 CLI(Claude Code/Codex)를 직접 사용하는 흐름

예: 외부 일정 중 급하게 핫픽스를 해야 하는 상황에서 폰으로 서버에 붙는다. 채팅 UI로 지시를 주고 결과를 기다리다 보면, 작은 조정 하나에도 왕복이 생기고 흐름이 끊긴다. 결국 tmux로 돌아가 터미널에서 직접 명령을 치는 쪽이 더 빠르게 느껴진다.

## 현황
clawdbot(moltbot)은 “원격에서 채팅 기반으로 코딩 에이전트를 굴리는 경험”을 전면에 내세우는 도구로 알려져 있습니다. 저는 며칠간 실제 개발 환경에 붙여 사용해봤고, 기대했던 것은 작업 방식이 달라지는 체감(패러다임 전환)이었습니다.

다만 사용이 익숙해질수록, 제 기준에서는 새 방식이라기보다 Claude Code를 감싸서 호출하는 한 겹의 인터페이스로 느껴졌습니다. 그래서 “도구가 나쁜가”가 아니라, “내가 원하는 변화가 여기서 일어나나” 관점에서 다시 평가하게 됐습니다.

## 분석
### 1) “래핑 도구”에 가까웠던 이유
제가 기대했던 변화는 “명령을 더 적게 치는 것”이 아니라 “문제를 쪼개고 검증하는 방식 자체가 달라지는 것”이었습니다. 그런데 실제 사용 경험에서는 핵심 로직이 여전히 Claude Code 중심으로 흐르고, 그 위에 대화형 UI가 한 단계 추가된 형태로 보였습니다.

그 결과, 컨텍스트가 어디에 쌓이고(채팅/터미널/레포), 무엇이 확정된 사실이고 무엇이 제안인지가 흐려지는 순간이 있었습니다. 저는 이 지점이 누적될수록 피로로 바뀌었습니다.

### 2) 모바일 코딩이 내게는 “추가 가치”가 아니었다
모바일 작업 자체가 새로운 문제를 풀어주는지 체감이 적었습니다. 이미 Tailscale + Termius + tmux 조합으로 개발 PC에 원격 접속해 작업하는 루틴이 있었고, 그 방식이 제가 원하는 “통제력”과 “속도”를 충분히 제공했습니다.

그래서 “폰에서도 코딩”은 장점이라기보다, 제가 이미 확보해둔 기능을 다른 방식으로 다시 제공받는 느낌에 가까웠습니다.

### 3) 채팅 UX의 왕복 비용
가장 크게 체감된 단점은 왕복 비용이었습니다. 작은 수정이나 미세한 방향 전환이 잦은 코딩 작업에서는, 채팅 기반 인터페이스가 매번 한 박자씩 늦게 따라오는 순간이 생깁니다.

저는 결국 tmux 안에서 순정 CLI(Claude Code/Codex)를 직접 띄우고, 내가 원하는 단위로 명령을 쪼개고 실행하는 방식으로 다시 돌아오게 됐습니다.

### 4) “에이전트면 코딩을 안 해도 된다”는 기대가 만들던 함정
에이전트를 제대로 쓰기 시작하면, 오히려 스크립트·로직·실패 케이스 처리 같은 “현실적인 코딩”이 늘어나는 구간이 있습니다. 이때 중요한 건 도구의 ‘마법’이 아니라, 실패를 복구하는 루프(재현→원인 파악→수정→검증)입니다.

저는 이 루프를 가장 짧게 유지해주는 환경이 터미널 기반 워크플로라고 판단했습니다.

## 실전 적용
**오늘 바로 할 일:**
- “새 도구를 붙이면 무엇이 바뀌어야 성공인가?”를 한 문장으로 정의한다. (예: 맥락 관리가 더 명확해져야 한다 / 왕복이 줄어야 한다)
- 실제 업무 티켓 하나에만 붙여서, 입력 단계(지시)와 출력 단계(검증) 사이의 왕복을 기록한다.
- 순정 CLI로 같은 작업을 했을 때의 속도/통제력과 비교해서, 유지할 도구와 버릴 도구를 결정한다.

## FAQ
**Q: 그럼 clawdbot(moltbot)은 쓸모가 없나요?**  
A: 아닙니다. 다만 “내게 필요한 변화”가 무엇인지에 따라 효용이 갈립니다. 원격 작업의 마찰을 줄이거나, 대화형 UX가 작업 습관에 맞는 사람에게는 장점이 될 수 있습니다.

**Q: 나는 왜 삭제했나요?**  
A: 제 환경에서는 모바일 접속은 이미 해결돼 있었고, 채팅 UX의 왕복 비용이 커서 통제력과 속도를 깎는 쪽으로 작동했습니다.

**Q: 지금 내 최적 조합은 뭔가요?**  
A: Tailscale + Termius + tmux로 원격 접속하고, tmux 안에서 Claude Code/Codex를 직접 사용하는 방식입니다.

## 결론
지금 시점에서 저는 “래퍼를 하나 더 얹는 것”보다 “순정 CLI를 더 깊게 쓰는 것”이 효율적이라고 결론 내렸습니다. clawdbot(moltbot)은 나쁜 도구라기보다, 제 작업 방식과는 맞지 않아 삭제한 도구였습니다.

## 참고 자료
- [Tailscale](https://tailscale.com/)
- [Termius](https://termius.com/)
- [tmux](https://github.com/tmux/tmux)
- [OpenAI Codex CLI (GitHub)](https://github.com/openai/codex)
- [Anthropic Claude Code (docs)](https://docs.anthropic.com/en/docs/claude-code)
